name: Required Checks

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - 'repositories/**/*.json'

jobs:
  # This job aggregates all required checks for branch protection
  all-checks-pass:
    name: All Required Checks
    runs-on: ubuntu-latest
    needs: [validate-json, check-duplicates, lint-filenames]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          if [ "${{ needs.validate-json.result }}" != "success" ] || \
             [ "${{ needs.check-duplicates.result }}" != "success" ] || \
             [ "${{ needs.lint-filenames.result }}" != "success" ]; then
            echo "‚ùå One or more required checks failed"
            echo ""
            echo "Results:"
            echo "  - validate-json: ${{ needs.validate-json.result }}"
            echo "  - check-duplicates: ${{ needs.check-duplicates.result }}"
            echo "  - lint-filenames: ${{ needs.lint-filenames.result }}"
            exit 1
          fi
          echo "‚úÖ All required checks passed!"

  validate-json:
    name: Validate JSON
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Fetch base branch
        run: |
          git remote add upstream https://github.com/${{ github.event.pull_request.base.repo.full_name }}.git || true
          git fetch upstream ${{ github.event.pull_request.base.ref }} --depth=1

      - name: Get changed files
        id: changed-files
        run: |
          CHANGED_FILES=$(git diff --name-only upstream/${{ github.event.pull_request.base.ref }}...HEAD -- 'repositories/**/*.json' | tr '\n' ' ')
          echo "all_changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "any_changed=true" >> $GITHUB_OUTPUT
          else
            echo "any_changed=false" >> $GITHUB_OUTPUT
          fi
          
          echo "Changed files: $CHANGED_FILES"

      - name: Validate JSON syntax and schema
        if: steps.changed-files.outputs.any_changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Validating JSON files..."
          
          ERRORS=0
          
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            # Skip deleted files
            if [ ! -f "$file" ]; then
              continue
            fi
            
            echo "Checking: $file"
            
            # Check JSON syntax
            if ! jq empty "$file" 2>/dev/null; then
              echo "‚ùå Invalid JSON syntax in: $file"
              ERRORS=$((ERRORS + 1))
              continue
            fi
            
            # Check required fields
            NAME=$(jq -r '.name // empty' "$file")
            OWNER=$(jq -r '.owner // empty' "$file")
            REPO=$(jq -r '.repo // empty' "$file")
            DESCRIPTION=$(jq -r '.description // empty' "$file")
            
            if [ -z "$NAME" ]; then
              echo "‚ùå Missing required field 'name' in: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            if [ -z "$OWNER" ]; then
              echo "‚ùå Missing required field 'owner' in: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            if [ -z "$REPO" ]; then
              echo "‚ùå Missing required field 'repo' in: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            if [ -z "$DESCRIPTION" ]; then
              echo "‚ùå Missing required field 'description' in: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            # Check description length
            if [ -n "$DESCRIPTION" ] && [ ${#DESCRIPTION} -gt 200 ]; then
              echo "‚ö†Ô∏è Description exceeds 200 characters in: $file"
            fi
            
            # Check if GitHub repo exists
            if [ -n "$OWNER" ] && [ -n "$REPO" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/$OWNER/$REPO")
              
              if [ "$HTTP_CODE" != "200" ]; then
                echo "‚ùå GitHub repository not found or not accessible: $OWNER/$REPO (HTTP $HTTP_CODE)"
                ERRORS=$((ERRORS + 1))
              else
                echo "‚úÖ Valid: $file"
              fi
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "::error::Validation failed with $ERRORS error(s)"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ All JSON files validated successfully"

  check-duplicates:
    name: Check Duplicates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check for duplicate entries
        run: |
          echo "üîç Checking for duplicate repository entries..."
          
          # Get all owner/repo combinations
          find repositories -name "*.json" -exec jq -r '"\(.owner)/\(.repo)"' {} \; 2>/dev/null | sort | uniq -d > /tmp/duplicates.txt
          
          if [ -s /tmp/duplicates.txt ]; then
            echo "‚ùå Found duplicate repository entries:"
            cat /tmp/duplicates.txt
            exit 1
          fi
          
          echo "‚úÖ No duplicate repository entries found"

  lint-filenames:
    name: Lint Filenames
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Fetch base branch
        run: |
          git remote add upstream https://github.com/${{ github.event.pull_request.base.repo.full_name }}.git || true
          git fetch upstream ${{ github.event.pull_request.base.ref }} --depth=1

      - name: Get changed files
        id: changed-files
        run: |
          CHANGED_FILES=$(git diff --name-only upstream/${{ github.event.pull_request.base.ref }}...HEAD -- 'repositories/**/*.json' | tr '\n' ' ')
          echo "all_changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "any_changed=true" >> $GITHUB_OUTPUT
          else
            echo "any_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate filenames
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          echo "üîç Validating filenames..."
          
          ERRORS=0
          
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            # Skip deleted files
            if [ ! -f "$file" ]; then
              continue
            fi
            
            FILENAME=$(basename "$file")
            
            # Check lowercase
            if [[ "$FILENAME" =~ [A-Z] ]]; then
              echo "‚ùå Filename contains uppercase letters: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            # Check no spaces
            if [[ "$FILENAME" =~ \  ]]; then
              echo "‚ùå Filename contains spaces: $file"
              ERRORS=$((ERRORS + 1))
            fi
            
            # Check valid characters (alphanumeric, hyphens, underscores)
            if [[ ! "$FILENAME" =~ ^[a-z0-9_-]+\.json$ ]]; then
              echo "‚ùå Filename contains invalid characters: $file (use only lowercase letters, numbers, hyphens, underscores)"
              ERRORS=$((ERRORS + 1))
            fi
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "::error::Found $ERRORS filename issue(s)"
            exit 1
          fi
          
          echo "‚úÖ All filenames are valid"
